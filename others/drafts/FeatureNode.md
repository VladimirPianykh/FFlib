# План разработки `FeatureNode`
**Внимание! В тексте есть классы и термины, определённые в других файлах проекта. Для удобства можно использовать поиск по файлам (Ctrl+Shift+F по умолчанию в VS Code).**

## Описание
Требуется реализовать функционал класса `FeatureNode`, отражающего файл с наследником `FeatureTransmissionContract`. Также нужно создать вспомогательные бизнес-объекты (ноды), описанные ниже.
<!-- Особое внимание уделить концепции Board-like Features. -->

При реализации необходимо соблюдать контракт, описанный в документации в файле `ProjectNode.java`.

## Постановка
Необходимо:
  1. Реализовать базовые конструкторы и методы `FeatureNode` для совместимости с общим API.
  2. Аналогичным образом реализовать `FeatureConfigNode`. Такие ноды содержат информацию об отображаемом имени экземпляра `Feature`.
  3. Добавить ноды `FeatureRendererNode`, `FeatureSaverNode` и `FeatureModelNode`. Они являются `InternalNode`.
  4. Добавить возможность генерации сигнатур `Feature`s вместе с их рендерерами, моделями и сейверами (см. требования к методам ниже).
  5. Создать `DefaultsRegistrationNode` с возможностью управления регистрацией (размещением в реестрах `StorageManager` и `RenderingManager`) рендереров/сейверов/моделей Features. 
      1. Добавить вложенные DTO-классы (скорее всего, `record`) `FeatureRendererRegistration`, `FeatureModelRegistration`, `FeatureSaverRegistration`.
      2. Качественно подготовить объект для расширения другими регистрациями (в том числе, *возможно*, `EditableGroup`) и регистрациями произвольных функций, а не фиксированных объектов. Только подготовить.
  6. Реализовать механизм определения полей-операций (java.util.Function/java.util.Consumer/..., оканчиваются на Op)
      1. Создать неизменяемый Value-object `Operation` для хранения информации об операции контракта передачи (`FeatureTransmissionContract`).
      2. Создать метод для получения списка этих полей (см. методы в следующем разделе) с проверкой наличия регистрирующего метода (`setOperationNameOp`, где `OperationName` - имя операции)
      3. Создать `DiagnosticService` для определения несогласованностей (нет метода регистрации или есть метод и нет регистрации). При этом стоит учесть, что регистрация может происходить как в модели, так и в рендерере (а может, даже в сейвере). По возможности искать регистрацию не  как строчку в конструкторе, а как вызов регистрирующего метода. Проблема должна при этом иметь опцию автоматического решения в виде добавления метода и/или добавления регистрации (при добавлении метода желательно сразу добавить регистрацию, чтобы избежать двух последовательных проблем).
      4. Добавить метод (тоже указанный в разделе про методы) для добавления нового поля-операции.
  7. Реализовать создание `FeatureConfigNode` из `FeatureNode` по имени нового `FeatureConfigNode` с аргументами по умолчанию (также описано ниже).

## Требования по методам/функциям (ниже только обязательные части API)
 Новые методы `FeatureNode`:
  - `createFeatureConfigNode(String featureName)` -> новая `FeatureConfigNode`
  - `getOperationList()` -> `List<Operation>`
  - `addOperations(Operation...)` -> `void` - добавляет поля-операции в `Feature`, регистрирует их во всех соответствующих данному контракту передачи (`TransmissionContract`) внутренних нодах сейверов, рендереров, моделей.
  - Конструктор `FeatureNode(FeaturePhysicalNode physicalNode)` -> нода, загруженная из файла, если файл (`physicalNode.exists()`) есть, или нода, только что созданная в заданном файле, если тот пуст

 Новые методы `ProjectGraph`:
  - `createFeatureNode(String name)` -> новая `FeatureNode` - создаёт `FeatureNode` с внутренним именем `name` (используя конструктор `FeatureNode(FeaturePhysicalNode physicalNode)`), а также `FeatureRendererNode`, `FeatureSaverNode` и `FeatureModelNode`.

 Методы `DefaultsRegistrationNode`:
  - `registerDefault(FeatureModelRegistration reg)` -> `void` - добавляет регистрацию модели как модели для заданного `Feature` (Ссылка на `FeatureNode` в модели). Возможно, этот контракт придётся изменить для уменьшения связности (вынести ссылку на `FeatureNode` в аргумент). Изменение API только при наличии серьёзных оснований.
  - `registerDefault(FeatureRendererRegistration reg)` -> `void` - аналог для рендереров
  - `registerDefault(FeatureSaverRegistration reg)` -> `void` - аналог для сейверов

## Дополнительные требования
 - `FeatureConfigNode` контролирует один `FeatureManager`.
 - Привязка `FeatureConfigNode` к ролям может происходить через лямбду, но это не самый надёжный метод, поэтому рекомендуется придумать иной способ декларации наличия у ролей разрешений и feature.

<!-- # Заметки -->
<!-- Класс должен управлять созданием `Feature`. Вероятно, при помощи изменений в лямбде, но лямбда мне не нравится своей ограниченностью. Декларативный стиль куда надёжнее.   -->
<!-- Особое внимание нужно уделить BL-Feature. Что такое BL-Feature, определено пока плохо, но их `FeatureConfigNode` ~~точно~~, вероятно, нужно уметь создавать через `ProjectGraph`. Не, не только для BL-Feature, вообще для любых `Feature` со строго заданным контрактом. Как его строго задать? Документация? Методы? Отдельные файлы с конфигурацией? Целые классы? Рефлексия с обнаружением фабричных методов и конструкторов? *Засчёт обнаружения методов, возвращающих `Feature` или `FeatureTransmissionContract`!*   -->
<!-- `FeatureConfigNode` контролирует один `FeatureManager`.   -->
<!-- Привязка `FeatureTransmissionContract`, `FeatureModel` и т. д. друг к другу при помощи `ProjectGraph`а   -->
<!-- Rendererы форм для создания `FeatureConfigNode`   -->
<!-- Другие `FeatureManager`ы и ~~контроль менеджеров над информацией о создании `FeatureConfigNode`~~   -->
<!-- Интерфейс `FeatureManager`   -->
<!-- Генерация сигнатур BL-Feature через методы `ProjectGraph`   -->
<!-- Пусть `FeatureConfigNode` принимает `FeatureCreationArgs`! `FeatureCreationArgs` = DTO-интерфейс, который в файловой реализации несёт аргументы в виде кода специально для заданного Feature. Какие методы у этого интерфейса?   -->
<!-- Graph suggestions/completions?   -->
<!-- OpenRouter for OurFuture!   -->
<!-- DiagnosticService для проблем с отсутствием регистрации нужных callbackов в конструкторах моделей и рендереров Feature. -->